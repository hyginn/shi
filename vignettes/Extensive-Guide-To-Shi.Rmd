---
title: "Extensive Guide to Shi"
author: "Adriel Martinez"
output:
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: refs.bib
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(fig.width=7, fig.height=5) 
library(shi)
```

## Introduction

### Sequence Logos

Sequence logos are a graphical method for displaying conservancy in a multiple sequence alignment. A stack of letters are displayed for every column in the alignment depicting the information for that particular column. While the total height of the stack depicts the information for that column, the letters themselves have heights that are proportional to their frequencies for that particular column. Information is calculated by subtracting the Shannon entropy from a maximum possible information which differs if the sequence is made up amino acids or nucleotides. [@schneider90]


### Shi

Shi (Sequence alignment Handling and Inspection) as well as shì (視) to inspect, is an R package that contains tools to assess multiple sequence alignment. For the purpose of this vignette, any reference to Shi will be about the sequence logo generation portion of the package.

The motivation behind this package is not the lack of sequence logos package in R ([ggseqlogo](https://github.com/omarwagih/ggseqlogo), [seqLogo](https://bioconductor.org/packages/release/bioc/html/seqLogo.html)), but the inflexibility of custom fonts, characters, sizes with the native R plotting system (nothing against the ggplot system of course). Another reason why this package was made was to address how information was being calculated and how it doesn't address that biological systems do not have equiprobable compositions [@uniprotKB15].

## Using shi

Using shi is simple as loading as calling `sequenceLogoR` with the multiple aligned sequence and specifying whether the inputs are amino acids or nucleotides. The default parameters should generate a traditional sequence logo.

### Quickstart

First of all, we need a multiple sequence alignment to feed in. I will be using the example sequence from the `msa` package, create a multiple sequence alignment, and transform it into an `AAStringSet`.

```{r message=FALSE, warning=FALSE}
# install the msa package if not found
if (! require(msa, quietly=TRUE)) {
  if (! exists("biocLite")) {
    source("https://bioconductor.org/biocLite.R")
  }
  biocLite("msa")
  library(msa)
}
```

```{r}
mySequenceFile <- system.file("examples", "exampleAA.fasta", package="msa")
mySequences <- readAAStringSet(mySequenceFile)
mySequences
```
```{r}
myFirstAlignment <- msa(mySequences, "Muscle")
myFirstAlignment
```
```{r}
alignment <- AAStringSet(myFirstAlignment)
alignment
partialAlignment <- subseq(alignment, start = 220, end = 240)
partialAlignment
```

Once we have our alignment, we just feed it to `sequenceLogoR`.
```{r message=FALSE, warning=FALSE}
sequenceLogoR(partialAlignment, isAminoAcid = TRUE)
```

### Customizing the residue display

Currently, the customizations that were possible, in regards of residue display, were being able to set the colors per residue, being able to set which character to represent a residue, and which font to use. A settings map must be generated and fed into `sequenceLogoR`.

The default settings were to not display different characters for the residues and to use a color pallete (`colorRampPalette(c("#C27E7E", "#816EBA", "#758AC9", "#82C9B6"))`)

```{r}
generateSettingsMap
```

#### Different Colors

Since the underlying plotting system for the sequence logos is just the native R plotting system, any valid R colors can be used.

```{r message=FALSE, warning=FALSE}
residues <- c("A", "R", "N", "D", "C", "Q", "E", "G", "H", "I",
              "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V")
randomColors <- colorRampPalette(c("blue", "red", "green"))(length(residues))
differentColors <- generateSettingsMap(residues, colors = randomColors)
sequenceLogoR(partialAlignment, settingsMap = differentColors, 
              isAminoAcid = TRUE)
```

#### Different Font

Different fonts can be used to generate the glyphs for the sequence logo. The packaged and default font is `NotoSans-Regular` acquired from [here](https://github.com/google/fonts/tree/master/ofl/notosans). Inlcuded with the NotoSans family is `NotoSans-Italic`.

```{r}
residues <- c("A", "R", "N", "D", "C", "Q", "E", "G", "H", "I",
              "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V")
italicsCharacters <- generateSettingsMap(residues, pathToFont =
                                           system.file("extdata/notosans",
                                              "NotoSans-Italic.ttf",
                                              package = "shi"))
sequenceLogoR(partialAlignment, settingsMap = italicsCharacters, 
              isAminoAcid = TRUE)
```


#### Different Characters

As long as the supplied font can support the character, there won't be a problem on using it instead of the residue character. 

```{r, fig.cap="An example with greek characters."}
residues <- c("A", "R", "N", "D", "C", "Q", "E", "G", "H", "I",
              "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V")
characters <- c("α", "β", "γ", "δ", "ε", "ζ", "η", "θ", "ι", "κ",
                "λ", "μ", "ν", "ξ", "ο", "π", "ρ", "σ", "τ", "υ")
greekCharacters <- generateSettingsMap(residues, characters = characters)
sequenceLogoR(partialAlignment, settingsMap = greekCharacters, 
              isAminoAcid = TRUE)
```

```{r, fig.cap="An example with Japanese characters."}
residues <- c("A", "R", "N", "D", "C", "Q", "E", "G", "H", "I",
              "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V")
characters <- c("試", "し", "打", "ち", "が","で", "き", "ま", "す", "。",
                "文", "字", "の", "太", "さ", "や", "サ", "イ", "ズ", "の")
japaneseCharacters <- generateSettingsMap(residues, characters = characters, 
                                          pathToFont = 
                                            system.file("extdata/sawarbi", 
                                              "SawarabiMincho-Regular.ttf", 
                                            package = "shi"))
sequenceLogoR(partialAlignment, settingsMap = japaneseCharacters, 
              isAminoAcid = TRUE)
```

### Entropy Methods

The prior sequence logos have all been generated using shannon entropy. As stated before, one of the motivations of this package was to address non equiprobable biological systems. Instead of using Shannon entropy, Kullback-Leibler divergence could be used to show relative divergence from a reference distribution with the observed distribution from the columns. [@kl51] While it is possible to display under represented residues, this has been omitted because of the feature of display gap information (later on). For the demo below, the frequencies from Uniprot KB 15 will be used for the reference distribution [@uniprotKB15].

```{r}
AAref <- numeric()
AAref["A"] <- 0.0854
AAref["C"] <- 0.0136
AAref["D"] <- 0.0526
AAref["E"] <- 0.0609
AAref["F"] <- 0.0402
AAref["G"] <- 0.0705
AAref["H"] <- 0.0222
AAref["I"] <- 0.0589
AAref["K"] <- 0.0522
AAref["L"] <- 0.0983
AAref["M"] <- 0.0242
AAref["N"] <- 0.0417
AAref["P"] <- 0.0484
AAref["Q"] <- 0.0393
AAref["R"] <- 0.0554
AAref["S"] <- 0.0684
AAref["T"] <- 0.0560
AAref["V"] <- 0.0665
AAref["W"] <- 0.0133
AAref["Y"] <- 0.0302
sequenceLogoR(partialAlignment, entropyMethod = "kl", isAminoAcid = TRUE, 
              refDistribution = AAref)
```

### Small Sample corrections

With a small amount of samples, the probabiliy of observing 0 information from a sample size that is not a multiple of the number of residues is 0. This small sample error overestimates what the true information from the alignment. To compensate, a small sample correction factor is applied to the calculated information. [@schneider86] In this package there are two types of corrections that can be done via the small sample correction defined by Schneider or by scaling via significance from simulations. This package has dynamic correction; to correct against the number of observed residues per column. This was done to penalize gappy regions as this don't show the full picture regarding conservation.


#### Correction by Schneider



## References